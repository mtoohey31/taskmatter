#!/usr/bin/env python3

import os
import re
from typing import Union
import argparse as ap
import datetime
from frontmatter import Frontmatter as fm
import yaml
import dateparser
from tabulate import tabulate

DEFAULT_CONFIG = {'default_path': ['./'], 'default_subcommand': 'week'}


def get_config() -> dict:
    """Determine if the user has created a configuration file, merge it with the
    default config, and return it."""
    config_paths = [os.path.join(os.path.expanduser('~'),
                                 '.config/taskmatter/config.yaml'),
                    os.path.join(os.path.expanduser('~'),
                                 '.config/taskmatter/config.yml')]
    for path in config_paths:
        if os.path.isfile(path):
            with open(path, 'r') as file:
                user_config = yaml.full_load(file)
                if user_config is None:
                    return DEFAULT_CONFIG
                else:
                    return {**DEFAULT_CONFIG, **user_config}
    return DEFAULT_CONFIG


def get_args() -> ap.Namespace:
    """Get the arguments provided by the user at the command line."""
    config = get_config()

    parser = ap.ArgumentParser(prog="taskmatter",
                               description='Process tasks in Markdown YAML '
                               'frontmatter.')
    subparsers = parser.add_subparsers(title='subcommands')
    parser.set_defaults(func=week, all=None,
                        paths=config['default_path'])

    week_parser = subparsers.add_parser('week', aliases=['w'])
    week_parser.add_argument(
        "paths", nargs='*', default=config['default_path'])
    week_parser.add_argument(
        '-a', action=ap.BooleanOptionalAction, dest="all")
    week_parser.add_argument(
        '-r', action=ap.BooleanOptionalAction, dest="recursive")
    week_parser.add_argument(
        '-w', action=ap.BooleanOptionalAction, dest="raw")
    week_parser.set_defaults(func=week)

    month_parser = subparsers.add_parser('month', aliases=['m'])
    month_parser.add_argument(
        "paths", nargs='*', default=config['default_path'])
    month_parser.add_argument(
        '-a', action=ap.BooleanOptionalAction, dest="all")
    month_parser.add_argument(
        '-r', action=ap.BooleanOptionalAction, dest="recursive")
    month_parser.add_argument(
        '-w', action=ap.BooleanOptionalAction, dest="raw")
    month_parser.set_defaults(func=month)

    add_parser = subparsers.add_parser('add', aliases=['a'])
    add_parser.add_argument("title", nargs='+')
    add_parser.set_defaults(func=add)

    edit_parser = subparsers.add_parser('edit', aliases=['e'])
    edit_parser.add_argument("ids", nargs='+')
    edit_parser.add_argument(
        '-r', action=ap.BooleanOptionalAction, dest="recursive")
    edit_parser.set_defaults(func=edit)

    done_parser = subparsers.add_parser('done', aliases=['d'])
    done_parser.add_argument("titles", nargs='+')
    done_parser.set_defaults(func=task_done)

    return parser.parse_args()


def get_fm(args: ap.Namespace) -> list[dict]:
    """Using the get_paths helper function, find the selected files and read
    their frontmatter, filtering out files that are not valid tasks."""
    paths = []
    get_paths(paths, args.paths, args)

    info = {file: get_info(file) for file in paths}
    tm_files = [file for file in paths if os.path.isfile(
        file) and os.path.splitext(file)[1] == '.md' and info[file] is not None]

    frontmatter_so_far = []
    for tm_file in tm_files:
        curr_frontmatter = fm.read_file(tm_file)['attributes']
        if curr_frontmatter is not None and '_tm' in curr_frontmatter:

            frontmatter_so_far.append({**{"path": tm_file}, **info[tm_file],
                                       **curr_frontmatter['_tm']})
        else:
            frontmatter_so_far.append({**{"path": tm_file}, **info[tm_file]})

    return frontmatter_so_far


def get_paths(paths: list[str], input_paths: list[str],
              args: ap.Namespace) -> None:
    """Using the provided arguments, determine which paths are potential tasks
    in the scope of the user's command."""
    for path in input_paths:
        if os.path.isfile(path):
            paths.append(path)
        else:
            for sub_path in os.listdir(path):
                if os.path.isfile(sub_path):
                    paths.append(sub_path)
                elif args.recursive:
                    get_paths(paths, [os.path.join(path, sub_path)], args)


def get_info(path: str) -> Union[dict[str, str], None]:
    """If the file matches the required pattern, return a dict containing the
    title and id of the file."""
    stem = os.path.splitext(os.path.basename(path))[0]

    if re.match(r'^.* \| [a-z]{1,}$', stem):
        return {"title": re.sub(r' \| [a-z]+$', '', stem),
                "id": re.sub(r'^.* \| (?=[a-z]+$)', '', stem)}
    else:
        return None


def main() -> None:
    """The main function of the program."""
    args = get_args()
    args.func(args)


def week(args: ap.Namespace) -> None:
    """The function corresponding to the `week` subcommand which prints the
    incomplete tasks for this week, or all tasks for this week if `-a` is
    specified."""
    frontmatter = get_fm(args)

    items = []
    for item in frontmatter:
        if not args.all and "done" in item and item['done']:
            continue

        if 'planned' in item:
            date = dateparser.parse(item['planned'])
        elif 'due' in item:
            date = dateparser.parse(item['due'])
        else:
            continue

        items.append((item['title'] + ' | ' + item['id'], date))

    today = datetime.datetime.today()
    weekday = today.isoweekday() % 7
    week_start = datetime.datetime(
        today.year, today.month, today.day - weekday)

    this_week = {}
    for day_offset in range(7):
        day_start = week_start + datetime.timedelta(days=day_offset)
        day_end = week_start + datetime.timedelta(days=day_offset + 1)
        sorted_items = sorted([item for item in items
                               if day_start < item[1] < day_end],
                              key=lambda x: x[1]) + \
            [item for item in items if item[1] == day_start]

        formatted_items = []
        for item in sorted_items:
            if item[1].time() != datetime.time.min:
                formatted_items.append(
                    item[0] + ' - ' + item[1].strftime('%-I:%M:%S %p'))
            else:
                formatted_items.append(item[0])

        this_week[day_start.strftime('%A, %b %-d')] = formatted_items

    for key in [(week_start +
                 datetime.timedelta(days=offset)).strftime('%A, %b %-d')
                for offset in range(7)]:
        if not this_week[key]:
            this_week.pop(key)
        else:
            break

    for key in [(week_start +
                 datetime.timedelta(days=offset)).strftime('%A, %b %-d')
                for offset in reversed(range(0, 7))]:
        if key in this_week and not this_week[key]:
            this_week.pop(key)
        elif key not in this_week:
            print('No tasks found')
            return None

    print(tabulate(this_week, headers='keys'))


def month(args: ap.Namespace) -> None:
    """The function corresponding to the `month` subcommand which prints the
    incomplete tasks for this month, or all tasks for this month if `-a` is
    specified."""
    raise NotImplementedError


def edit(args: ap.Namespace) -> None:
    """The function corresponding to the `edit` subcommand that edits the tasks
    with the given ids."""
    frontmatter = get_fm(args)
    for item_id in args.ids:
        for item in frontmatter:
            if item['id'] == item_id:
                os.system('$EDITOR "' + item['path'] + '"')


def add(args: ap.Namespace) -> None:
    """The function corresponding to the `add` command that creates a new task
    with the given title."""
    raise NotImplementedError


def task_done(args: ap.Namespace) -> None:
    """The function corresponding to the `done` command that marks the tasks
    with the given ids as done."""
    raise NotImplementedError


if __name__ == '__main__':
    main()
