#!/usr/bin/env python3

import os
import re
from typing import Union, Any
import argparse as ap
import datetime as dt
import frontmatter as fm
import yaml
import dateparser as dp

DEFAULT_CONFIG = {'default_path': ['./'], 'default_subcommand': 'week'}


def get_config() -> dict:
    """Determine if the user has created a configuration file, merge it with the
    default config, and return it."""
    config_paths = [os.path.join(os.path.expanduser('~'),
                                 '.config/taskmatter/config.yaml'),
                    os.path.join(os.path.expanduser('~'),
                                 '.config/taskmatter/config.yml')]
    for path in config_paths:
        if os.path.isfile(path):
            with open(path, 'r') as file:
                user_config = yaml.full_load(file)
                if user_config is None:
                    return DEFAULT_CONFIG
                else:
                    return {**DEFAULT_CONFIG, **user_config}
    return DEFAULT_CONFIG


def get_args() -> ap.Namespace:
    """Get the arguments provided by the user at the command line."""
    config = get_config()

    parser = ap.ArgumentParser(prog="taskmatter",
                               description='Process tasks in Markdown YAML '
                               'frontmatter.')
    subparsers = parser.add_subparsers(title='subcommands')
    parser.set_defaults(func=week, all=None, recursive=None,
                        paths=config['default_path'])

    week_parser = subparsers.add_parser('week', aliases=['w'])
    week_parser.add_argument(
        "paths", nargs='*', default=config['default_path'])
    week_parser.add_argument(
        '-a', action=ap.BooleanOptionalAction, dest="all")
    week_parser.add_argument(
        '-r', action=ap.BooleanOptionalAction, dest="recursive")
    week_parser.add_argument(
        '-w', action=ap.BooleanOptionalAction, dest="raw")
    week_parser.set_defaults(func=week)

    month_parser = subparsers.add_parser('month', aliases=['m'])
    month_parser.add_argument(
        "paths", nargs='*', default=config['default_path'])
    month_parser.add_argument(
        '-a', action=ap.BooleanOptionalAction, dest="all")
    month_parser.add_argument(
        '-r', action=ap.BooleanOptionalAction, dest="recursive")
    month_parser.add_argument(
        '-w', action=ap.BooleanOptionalAction, dest="raw")
    month_parser.set_defaults(func=month)

    add_parser = subparsers.add_parser('add', aliases=['a'])
    add_parser.add_argument("title", nargs='+')
    add_parser.set_defaults(func=add)

    edit_parser = subparsers.add_parser('edit', aliases=['e'])
    edit_parser.add_argument("ids", nargs='+')
    edit_parser.add_argument(
        '-r', action=ap.BooleanOptionalAction, dest="recursive")
    edit_parser.set_defaults(func=edit)

    done_parser = subparsers.add_parser('done', aliases=['d'])
    done_parser.add_argument("titles", nargs='+')
    done_parser.set_defaults(func=task_done)

    return parser.parse_args()


def get_fm(args: ap.Namespace) -> list[dict]:
    """Using the get_paths helper function, find the selected files and read
    their frontmatter, filtering out files that are not valid tasks."""
    paths = []
    get_paths(paths, args.paths, args)

    info = {file: get_info(file) for file in paths}
    tm_files = [file for file in paths if os.path.isfile(
        file) and os.path.splitext(file)[1] in ['.md', '.pmd', '.rmd', '.Rmd']
        and info[file] is not None]

    frontmatter_so_far = []
    for tm_file in tm_files:
        curr_frontmatter = fm.load(tm_file)
        if curr_frontmatter is not None and '_tm' in curr_frontmatter:

            frontmatter_so_far.append({**{"path": tm_file}, **info[tm_file],
                                       **curr_frontmatter['_tm']})
        else:
            frontmatter_so_far.append({**{"path": tm_file}, **info[tm_file]})

    return frontmatter_so_far


def get_paths(paths: list[str], input_paths: list[str],
              args: ap.Namespace) -> None:
    """Using the provided arguments, determine which paths are potential tasks
    in the scope of the user's command."""
    for path in input_paths:
        if os.path.isfile(path):
            paths.append(path)
        else:
            for sub_path in os.listdir(path):
                if os.path.isfile(sub_path):
                    paths.append(sub_path)
                elif args.recursive:
                    get_paths(paths, [os.path.join(path, sub_path)], args)


def get_info(path: str) -> Union[dict[str, str], None]:
    """If the file matches the required pattern, return a dict containing the
    title and id of the file."""
    stem = os.path.splitext(os.path.basename(path))[0]

    if re.match(r'^.* \| [a-z]{3}$', stem):
        return {"title": re.sub(r' \| [a-z]{3}$', '', stem),
                "id": re.sub(r'^.* \| (?=[a-z]{3}$)', '', stem)}
    else:
        return None


def main() -> None:
    """The main function of the program."""
    args = get_args()
    args.func(args)


def week(args: ap.Namespace) -> None:
    """The function corresponding to the `week` subcommand which prints the
    incomplete tasks for this week, or all tasks for this week if `-a` is
    specified."""
    frontmatter = get_fm(args)

    today = dt.datetime.today()
    weekday = today.isoweekday() % 7
    week_start = dt.datetime(today.year, today.month, today.day - weekday)

    week = []
    dropped_days = []

    for day_offset in range(7):
        day_start = week_start + dt.timedelta(days=day_offset)
        day_end = week_start + dt.timedelta(days=day_offset + 1)
        sorted_tasks = sorted([task for task in frontmatter if
                               ('done' not in task or not task['done']
                                or args.all) and
                               (('planned' in task and
                                day_start < dp.parse(task['planned']) < day_end) or
                                ('planned' not in task and 'due' in task and
                                day_start < dp.parse(task['due']) < day_end))],
                              key=lambda x: x['planned'] if 'planned' in x else x['due']) + \
            [task for task in frontmatter if
             ('done' not in task or not task['done'] or args.all) and
             (('planned' in task and dp.parse(task['planned']) == day_start) or
              ('planned' not in task and 'due' in task
               and dp.parse(task['due']) == day_start))]

        formatted_tasks = []

        for task in sorted_tasks:
            task_str_so_far = task['title'] + ' - ' + task['id']
            task_time = dp.parse(
                task['planned'] if 'planned' in task else task['due']).time()
            if task_time != dt.time.min:
                task_str_so_far += ' - ' + task_time.strftime('%-I:%M:%S %p')
            formatted_tasks.append(task_str_so_far)

        if formatted_tasks:
            week.extend([{'day': day, 'tasks': []} for day in dropped_days])
            dropped_days = []
            week.append({'day': day_start.strftime(
                ' %A, %b %-d '), 'tasks': formatted_tasks})
        elif week:
            dropped_days.append(day_start.strftime(' %A, %b %-d '))

    if week:
        print(_format_week_table(week))
    else:
        print('No tasks found')


def _format_week_table(week: list[dict[str, Any]]) -> str:
    block_height = max([len(day['tasks']) for day in week], default=0)
    for day in week:
        day['tasks'].extend([''] * (block_height - len(day['tasks'])))
    for day in week:
        day['width'] = max([len(task)
                           for task in day['tasks']] + [len(day['day'])])
        day['day'] = day['day'] + ' ' * (day['width'] - len(day['day']))
        for i in range(len(day['tasks'])):
            day['tasks'][i] = day['tasks'][i] + ' ' * \
                (day['width'] - len(day['tasks'][i]))

    table_so_far = '┌' + '┬'.join(['─' * day['width'] for day in week]) + '┐'
    table_so_far += '\n│' + '│'.join([day['day'] for day in week]) + '│'
    table_so_far += '\n├' + \
        '┼'.join(['─' * day['width'] for day in week]) + '┤'
    for i in range(block_height):
        table_so_far += '\n│' + \
            '│'.join([day['tasks'][i] for day in week]) + '│'

    table_so_far += '\n└' + \
        '┴'.join(['─' * day['width'] for day in week]) + '┘'
    return table_so_far


def month(args: ap.Namespace) -> None:
    """The function corresponding to the `month` subcommand which prints the
    incomplete tasks for this month, or all tasks for this month if `-a` is
    specified."""
    raise NotImplementedError


def edit(args: ap.Namespace) -> None:
    """The function corresponding to the `edit` subcommand that edits the tasks
    with the given ids."""
    frontmatter = get_fm(args)
    for item_id in args.ids:
        for item in frontmatter:
            if item['id'] == item_id:
                os.system('$EDITOR "' + item['path'] + '"')


def add(args: ap.Namespace) -> None:
    """The function corresponding to the `add` command that creates a new task
    with the given title."""
    raise NotImplementedError


def task_done(args: ap.Namespace) -> None:
    """The function corresponding to the `done` command that marks the tasks
    with the given ids as done."""
    raise NotImplementedError


if __name__ == '__main__':
    main()
