#!/usr/bin/env python3

import os
import re
from typing import Union, Any
from io import BytesIO
import random as rd
import argparse as ap
import datetime as dt
import frontmatter as fm
import yaml
import dateparser as dp
from dateparser.date import DateDataParser as ddp

DEFAULT_CONFIG = {'default_path': ['./'], 'default_subcommand': 'week'}


def get_config() -> dict:
    """Determine if the user has created a configuration file, merge it with the
    default config, and return it."""
    config_paths = [os.path.join(os.path.expanduser('~'),
                                 '.config/taskmatter/config.yaml'),
                    os.path.join(os.path.expanduser('~'),
                                 '.config/taskmatter/config.yml')]
    for path in config_paths:
        if os.path.isfile(path):
            with open(path, 'r') as file:
                user_config = yaml.full_load(file)
                if user_config is None:
                    return DEFAULT_CONFIG
                else:
                    return {**DEFAULT_CONFIG, **user_config}
    return DEFAULT_CONFIG


def get_args() -> ap.Namespace:
    """Get the arguments provided by the user at the command line."""
    config = get_config()

    parser = ap.ArgumentParser(prog="taskmatter",
                               description='Process tasks in Markdown YAML '
                               'frontmatter.')
    subparsers = parser.add_subparsers(title='subcommands')
    parser.set_defaults(func=week, all=None, recursive=None,
                        paths=config['default_path'])

    week_parser = subparsers.add_parser('week', aliases=['w'])
    week_parser.add_argument(
        "paths", nargs='*', default=config['default_path'])
    week_parser.add_argument('-n', dest="next", default=0)
    week_parser.add_argument(
        '-a', action=ap.BooleanOptionalAction, dest="all")
    week_parser.add_argument(
        '-r', action=ap.BooleanOptionalAction, dest="recursive")
    week_parser.add_argument(
        '-w', action=ap.BooleanOptionalAction, dest="raw")
    week_parser.set_defaults(func=week)

    month_parser = subparsers.add_parser('month', aliases=['m'])
    month_parser.add_argument(
        "paths", nargs='*', default=config['default_path'])
    month_parser.add_argument('-n', dest="next", default=0)
    month_parser.add_argument(
        '-a', action=ap.BooleanOptionalAction, dest="all")
    month_parser.add_argument(
        '-r', action=ap.BooleanOptionalAction, dest="recursive")
    month_parser.add_argument(
        '-w', action=ap.BooleanOptionalAction, dest="raw")
    month_parser.set_defaults(func=month)

    add_parser = subparsers.add_parser('add', aliases=['a'])
    add_parser.add_argument("title")
    add_parser.add_argument("props", nargs="*")
    add_parser.set_defaults(recursive=False)
    add_parser.set_defaults(func=add)

    edit_parser = subparsers.add_parser('edit', aliases=['e'])
    edit_parser.add_argument("targets", nargs='+')
    edit_parser.add_argument(
        '-r', action=ap.BooleanOptionalAction, dest="recursive")
    edit_parser.set_defaults(func=edit)

    done_parser = subparsers.add_parser('done', aliases=['d'])
    done_parser.add_argument("targets", nargs='+')
    done_parser.set_defaults(func=done)

    return parser.parse_args()


def get_fm(args: ap.Namespace) -> list[dict]:
    """Using the get_paths helper function, find the selected files and read
    their frontmatter, filtering out files that are not valid tasks."""
    paths = []
    get_paths(paths, args.paths, args)

    info = {file: get_info(file) for file in paths}
    tm_files = [file for file in paths if os.path.isfile(
        file) and os.path.splitext(file)[1] in ['.md', '.pmd', '.rmd', '.Rmd']
        and info[file] is not None]

    frontmatter_so_far = []
    for tm_file in tm_files:
        curr_frontmatter = fm.load(tm_file)
        if curr_frontmatter is not None and '_tm' in curr_frontmatter:

            frontmatter_so_far.append({**{"path": tm_file}, **info[tm_file],
                                       **curr_frontmatter['_tm']})
        else:
            frontmatter_so_far.append({**{"path": tm_file}, **info[tm_file]})

    return frontmatter_so_far


def get_paths(paths: list[str], input_paths: list[str],
              args: ap.Namespace) -> None:
    """Using the provided arguments, determine which paths are potential tasks
    in the scope of the user's command."""
    for path in input_paths:
        if os.path.isfile(path):
            paths.append(path)
        else:
            for sub_path in os.listdir(path):
                if os.path.isfile(sub_path):
                    paths.append(sub_path)
                elif args.recursive:
                    get_paths(paths, [os.path.join(path, sub_path)], args)


def get_info(path: str) -> Union[dict[str, str], None]:
    """If the file matches the required pattern, return a dict containing the
    title and id of the file."""
    stem = os.path.splitext(os.path.basename(path))[0]

    if re.match(r'^.* \| [a-z]{3}$', stem):
        return {"title": re.sub(r' \| [a-z]{3}$', '', stem),
                "id": re.sub(r'^.* \| (?=[a-z]{3}$)', '', stem)}
    else:
        return None


def main() -> None:
    """The main function of the program."""
    args = get_args()
    args.func(args)


def week(args: ap.Namespace) -> None:
    """The function corresponding to the `week` subcommand which prints the
    incomplete tasks for this week, or all tasks for this week if `-a` is
    specified."""
    frontmatter = get_fm(args)

    today = dt.datetime.today()
    weekday = today.isoweekday()
    week_start = dt.datetime(today.year, today.month,
                             today.day - weekday + (7 * int(args.next)))

    week = []
    dropped_days = []

    for day_offset in range(7):
        day_start = week_start + dt.timedelta(days=day_offset)
        day_end = week_start + dt.timedelta(days=day_offset + 1)
        sorted_tasks = sorted([task for task in frontmatter if
                               ('done' not in task or not task['done']
                                or args.all) and
                               (('planned' in task and
                                day_start < dp.parse(task['planned']) < day_end) or
                                ('planned' not in task and 'due' in task and
                                day_start < dp.parse(task['due']) < day_end))],
                              key=lambda x: x['planned'] if 'planned' in x else x['due']) + \
            [task for task in frontmatter if
             ('done' not in task or not task['done'] or args.all) and
             (('planned' in task and dp.parse(task['planned']) == day_start) or
              ('planned' not in task and 'due' in task
               and dp.parse(task['due']) == day_start))]

        formatted_tasks = []

        for task in sorted_tasks:
            task_str_so_far = task['title'] + ' - ' + task['id']
            task_time = dp.parse(
                task['planned'] if 'planned' in task else task['due']).time()
            if task_time != dt.time.min:
                task_str_so_far += ' - ' + task_time.strftime('%-I:%M:%S %p')
            formatted_tasks.append(task_str_so_far)

        if formatted_tasks:
            week.extend([{'day': day, 'tasks': []} for day in dropped_days])
            dropped_days = []
            week.append({'day': day_start.strftime(
                '%A, %b %-d'), 'tasks': formatted_tasks})
        elif week:
            dropped_days.append(day_start.strftime('%A, %b %-d'))

    if week:
        print(_format_week_table(week))
    else:
        print('No tasks found')


def _format_week_table(week: list[dict[str, Any]]) -> str:
    block_height = max([len(day['tasks']) for day in week], default=0)
    for day in week:
        day['tasks'].extend([''] * (block_height - len(day['tasks'])))
    for day in week:
        day['width'] = max([len(task)
                           for task in day['tasks']] + [len(day['day'])])
        day['day'] = day['day'] + ' ' * (day['width'] - len(day['day']))
        for i in range(len(day['tasks'])):
            day['tasks'][i] = day['tasks'][i] + ' ' * \
                (day['width'] - len(day['tasks'][i]))

    table_so_far = '┌' + '┬'.join(['─' * day['width'] for day in week]) + '┐'
    table_so_far += '\n│' + '│'.join([day['day'] for day in week]) + '│'
    table_so_far += '\n├' + \
        '┼'.join(['─' * day['width'] for day in week]) + '┤'
    for i in range(block_height):
        table_so_far += '\n│' + \
            '│'.join([day['tasks'][i] for day in week]) + '│'

    table_so_far += '\n└' + \
        '┴'.join(['─' * day['width'] for day in week]) + '┘'
    return table_so_far


def month(args: ap.Namespace) -> None:
    """The function corresponding to the `month` subcommand which prints the
    incomplete tasks for this month, or all tasks for this month if `-a` is
    specified."""
    frontmatter = get_fm(args)

    today = dt.datetime.today()
    month_start_weekday = dt.datetime(today.year, today.month +
                                      int(args.next), 1).isoweekday()
    month_start = dt.datetime(
        today.year, today.month + int(args.next), 1) - dt.timedelta(days=month_start_weekday)
    month_end_weekday = (dt.datetime(today.year, (today.month + int(args.next)) % 12 +
                                     1, 1) - dt.timedelta(days=1)).isoweekday()
    month_end = (dt.datetime(today.year, (today.month + int(args.next)) % 12 +
                             1, 1) + dt.timedelta(days=6 - month_end_weekday))

    curr_sunday = month_start
    sundays = [curr_sunday]
    curr_sunday += dt.timedelta(days=7)
    while curr_sunday < month_end:
        sundays.append(curr_sunday)
        curr_sunday += dt.timedelta(days=7)

    month = []
    dropped_weeks = []

    for week_start in sundays:

        week = []

        for day_offset in range(7):
            day_start = week_start + dt.timedelta(days=day_offset)
            day_end = week_start + dt.timedelta(days=day_offset + 1)
            sorted_tasks = sorted([task for task in frontmatter if
                                   ('done' not in task or not task['done']
                                    or args.all) and
                                   (('planned' in task and
                                    day_start < dp.parse(task['planned']) < day_end) or
                                    ('planned' not in task and 'due' in task and
                                    day_start < dp.parse(task['due']) < day_end))],
                                  key=lambda x: x['planned'] if 'planned' in x else x['due']) + \
                [task for task in frontmatter if
                 ('done' not in task or not task['done'] or args.all) and
                 (('planned' in task and dp.parse(task['planned']) == day_start) or
                  ('planned' not in task and 'due' in task
                   and dp.parse(task['due']) == day_start))]

            formatted_tasks = []

            for task in sorted_tasks:
                task_str_so_far = task['title'] + ' - ' + task['id']
                task_time = dp.parse(
                    task['planned'] if 'planned' in task else task['due']).time()
                if task_time != dt.time.min:
                    task_str_so_far += ' - ' + \
                        task_time.strftime('%-I:%M:%S %p')
                formatted_tasks.append(task_str_so_far)

            week.append({'day': day_start.strftime(
                '%-d'), 'tasks': formatted_tasks})

        month.append(week)

    print(_format_month_table(month,
                              [{'day': (month_start +
                                dt.timedelta(days=i)).strftime('%A')}
                               for i in range(7)], today.strftime('%B')))


def _format_month_table(month: list[dict[str, Any]], weekdays: list[dict],
                        month_name: str) -> str:
    for week in month:
        block_height = max([len(day['tasks']) for day in week], default=0)
        for day in week:
            day['tasks'].extend([''] * (block_height - len(day['tasks'])))

    for i in range(7):
        weekdays[i]['width'] = max(
            max([len(task) for task in week[i]['tasks']] +
                [len(week[i]['day'])] + [len(weekdays[i]['day'])])
            for week in month)
        weekdays[i]['day'] += ' ' * \
            (weekdays[i]['width'] - len(weekdays[i]['day']))
        for week in month:
            week[i]['day'] += ' ' * \
                (weekdays[i]['width'] - len(week[i]['day']))
            for j in range(len(week[i]['tasks'])):
                week[i]['tasks'][j] += ' ' * \
                    (weekdays[i]['width'] - len(week[i]['tasks'][j]))

    total_width = sum([weekday['width'] for weekday in weekdays]) + 8
    table_so_far = '┌' + '─' * (total_width - 2) + '┐'
    table_so_far += '\n│' + month_name + ' ' * \
        (total_width - 2 - len(month_name)) + '│'
    table_so_far += '\n├' + \
        '┬'.join(['─' * weekday['width'] for weekday in weekdays]) + '┤'
    table_so_far += '\n│' + '│'.join([weekday['day']
                                     for weekday in weekdays]) + '│'
    for week in month:
        table_so_far += '\n├' + \
            '┼'.join(['─' * weekday['width'] for weekday in weekdays]) + '┤'
        table_so_far += '\n│' + \
            '│'.join([task['day'] for task in week]) + '│'
        if len(week[0]['tasks']) != 0:
            for i in range(len(week[0]['tasks'])):
                table_so_far += '\n│' + \
                    '│'.join([task['tasks'][i] for task in week]) + '│'
    table_so_far += '\n└' + \
        '┴'.join(['─' * weekday['width'] for weekday in weekdays]) + '┘'

    return table_so_far


def add(args: ap.Namespace) -> None:
    """The function corresponding to the `add` command that creates a new task
    with the given title."""
    paths = []
    get_paths(paths, args.paths, args)

    info = {file: get_info(file) for file in paths}

    id = ''.join([chr(rd.randint(97, 122)) for _ in range(3)])
    while id in [info[file]['id'] for file in info]:
        id = ''.join([chr(rd.randint(97, 122)) for _ in range(3)])

    props = {}
    for prop in args.props:
        if len(prop.split(':')) == 2:
            key, value = prop.split(':')
        else:
            key = prop.split(':')[0]
            value = ':'.join(prop.split(':')[1:])

        parser = ddp(settings={'RETURN_TIME_AS_PERIOD': True})
        date = parser.get_date_data(value)
        if date.date_obj is None and key in ['planned', 'due']:
            raise ValueError(
                f'Provided `{key}` value could not be parsed as a date')
        elif date.date_obj is None:
            props[key] = value
        else:
            if date.period == 'time':
                if date.date_obj.second == 0:
                    props[key] = date.date_obj.strftime(
                        '%B %-d, %Y, %-I:%M %p')
                else:
                    props[key] = date.date_obj.strftime(
                        '%B %-d, %Y, %-I:%M:%S %p')
            else:
                props[key] = date.date_obj.strftime('%B %-d, %Y')

    f = BytesIO()
    if props:
        fm.dump(fm.Post(f'# {args.title}', **{'_tm': props}), f)
    else:
        fm.dump(fm.Post(f'# {args.title}', **{'_tm': None}), f)

    with open(f'./{args.title} | {id}.md', 'w') as file:
        file.write(f.getvalue().decode('utf8') + '\n')


def edit(args: ap.Namespace) -> None:
    """The function corresponding to the `edit` subcommand that edits the tasks
    with the given ids/paths."""
    frontmatter = get_fm(args)
    for target in args.targets:
        if re.match(r'^[a-z]{3}$', target):
            for item in frontmatter:
                if item['id'] == target:
                    os.system('$EDITOR "' + item['path'] + '"')
                    break
            else:
                print(f'No task with id: "{target}" found')
        elif os.path.exists(target):
            os.system('$EDITOR "' + target + '"')
        else:
            print(f'Could not parse task "{target}"')


def done(args: ap.Namespace) -> None:
    """The function corresponding to the `done` command that marks the tasks
    with the given ids/paths as done."""
    frontmatter = get_fm(args)
    for target in args.targets:
        if re.match(r'^[a-z]{3}$', target):
            for item in frontmatter:
                if item['id'] == target:
                    f = BytesIO()
                    file_fm = fm.load(item['path'])
                    if '_tm' in file_fm and \
                            (isinstance(file_fm['_tm'], dict)
                             or file_fm['_tm'] is None):
                        file_fm['_tm']['done'] = True
                    elif '_tm' in file_fm:
                        raise ValueError(
                            f'{target} contains unsupported `_tm` key')
                    else:
                        file_fm['_tm'] = {'done': True}
                    fm.dump(file_fm, f)

                    with open(item['path'], 'w') as file:
                        file.write(f.getvalue().decode('utf8') + '\n')

                    break
            else:
                print(f'No task with id: "{target}" found')
        elif os.path.exists(target):
            f = BytesIO()
            file_fm = fm.load(target)
            if '_tm' in file_fm and \
                    (isinstance(file_fm['_tm'], dict)
                     or file_fm['_tm'] is None):
                file_fm['_tm']['done'] = True
            elif '_tm' in file_fm:
                raise ValueError(
                    f'{target} contains unsupported `_tm` key')
            else:
                file_fm['_tm'] = {'done': True}
            fm.dump(file_fm, f)

            with open(target, 'w') as file:
                file.write(f.getvalue().decode('utf8') + '\n')
        else:
            print(f'Could not parse task "{target}"')


if __name__ == '__main__':
    main()
